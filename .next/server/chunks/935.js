exports.id=935,exports.ids=[935],exports.modules={9590:()=>{},2539:(e,t,o)=>{Promise.resolve().then(o.bind(o,195)),Promise.resolve().then(o.bind(o,2636))},3518:(e,t,o)=>{Promise.resolve().then(o.t.bind(o,3724,23)),Promise.resolve().then(o.t.bind(o,5365,23)),Promise.resolve().then(o.t.bind(o,4900,23)),Promise.resolve().then(o.t.bind(o,4714,23)),Promise.resolve().then(o.t.bind(o,5392,23)),Promise.resolve().then(o.t.bind(o,8898,23))},195:(e,t,o)=>{"use strict";o.r(t),o.d(t,{AuthProvider:()=>AuthProvider,useAuth:()=>useAuth});var n=o(784),l=o(9885),a=o(1771),r=o(8699);let s=(0,l.createContext)(void 0);function AuthProvider({children:e}){let{wallet:t,publicKey:o,connected:c,connect:i,disconnect:d,wallets:g}=(0,a.O)(),[u,p]=(0,l.useState)(null),[h,m]=(0,l.useState)(!1),[f,w]=(0,l.useState)(null),[y,v]=(0,l.useState)(!1);(0,l.useEffect)(()=>{console.log("AuthContext wallet state changed:",{wallet:t?.adapter?.name,connected:c,publicKey:o?.toString(),walletReady:t?.adapter?.readyState}),t?.adapter&&!c&&console.log("Wallet adapter available:",{name:t.adapter.name,readyState:t.adapter.readyState,connected:t.adapter.connected})},[t,c,o]),(0,l.useEffect)(()=>{let e=localStorage.getItem("auth_token"),t=localStorage.getItem("wallet_address");e&&t&&(console.log("Found existing token:",e),console.log("Token length:",e.length),console.log("Stored wallet address:",t),validateToken(e).then(o=>{if(o){console.log("Token is valid, setting user"),p({walletAddress:t,token:e}),console.log("Attempting to restore wallet connection...");let o=g.find(e=>"Phantom"===e.adapter.name);o&&"Installed"===o.adapter.readyState&&console.log("Phantom wallet is available, checking if we can restore connection")}else console.log("Token is invalid, clearing storage"),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address")}))},[g]),(0,l.useEffect)(()=>{if(!t?.adapter)return;let handleAccountChange=()=>{if(y){console.log("Already disconnecting, ignoring account change event");return}console.log("Account changed, disconnecting user"),v(!0),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address"),p(null),w(null),setTimeout(()=>{v(!1)},1e3)};return t.adapter.on("disconnect",handleAccountChange),u&&u.walletAddress&&!c&&"Installed"===t.adapter.readyState&&(console.log("Attempting to restore wallet connection for existing user..."),setTimeout(async()=>{try{await t.adapter.connect(),console.log("Wallet connection restored successfully")}catch(e){console.log("Could not restore wallet connection automatically:",e)}},1e3)),()=>{t.adapter.off("disconnect",handleAccountChange)}},[t,d,u,c]);let signMessage=async e=>{let o=t;if(!o||!o.adapter.publicKey){let e=g.find(e=>"Phantom"===e.adapter.name&&e.adapter.publicKey);e&&(o=e,console.log("Using Phantom wallet from available wallets for signing"))}if(!o||!o.adapter.publicKey)throw Error("Wallet not connected");try{let t=new TextEncoder().encode(e);if(!("signMessage"in o.adapter)||"function"!=typeof o.adapter.signMessage)throw Error("Wallet does not support message signing");let n=await o.adapter.signMessage(t);return Buffer.from(n).toString("base64")}catch(e){throw console.error("Sign message error:",e),Error("Failed to sign message")}},validateToken=async e=>{try{console.log("Validating token..."),console.log("Token being validated:",e),console.log("Authorization header:",`Bearer ${e}`);let t=await fetch(`${(0,r.k)()}/auth/me`,{method:"GET",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"}});if(console.log("Token validation response:",t.status),!t.ok){let e=await t.json().catch(()=>({}));console.log("Token validation error:",e)}return t.ok}catch(e){return console.error("Token validation failed:",e),!1}},connectWallet=async()=>{console.log("Attempting to connect wallet..."),console.log("Available wallet:",t),console.log("Connected:",c),console.log("Public key:",o),console.log("Available wallets in AuthContext:",g.map(e=>e.adapter.name));let e=g.find(e=>"Phantom"===e.adapter.name);if(!e){w("No Phantom wallet found. Please install Phantom wallet and refresh the page."),m(!1);return}console.log("Using Phantom wallet directly for connection"),w(null),m(!0);try{console.log("Connecting with Phantom wallet directly...");try{let t=await e.adapter.connect();console.log("Phantom wallet connect result:",t)}catch(e){console.log("Direct Phantom connect failed:",e),console.log("Trying useWallet connect() as fallback...");try{await i(),console.log("useWallet connect() successful")}catch(e){throw console.log("useWallet connect() also failed:",e),Error("Failed to connect to Phantom wallet")}}await new Promise(e=>setTimeout(e,1e3));let n=null;if(e&&e.adapter.publicKey?(n=e.adapter.publicKey,console.log("Got public key from direct Phantom wallet")):t&&t.adapter&&t.adapter.publicKey?(n=t.adapter.publicKey,console.log("Got public key from selected wallet")):o&&(n=o,console.log("Got public key from useWallet hook")),console.log("Wallet public key (first attempt):",n),!n){console.log("Public key not available, retrying...");for(let l=0;l<10&&(await new Promise(e=>setTimeout(e,300)),e&&e.adapter.publicKey?n=e.adapter.publicKey:t&&t.adapter&&t.adapter.publicKey?n=t.adapter.publicKey:o&&(n=o),console.log(`Retry ${l+1}:`,n),!n);l++);}if(!n)throw Error("Failed to get public key from wallet adapter after retries. Please try connecting again.");let l=n.toString(),a=`Sign this message to authenticate with Crypto EuroMillions.
Wallet: ${l}
Timestamp: ${Date.now()}`;console.log("Signing message...");let s=await signMessage(a);console.log("Message signed successfully"),console.log("Signature length:",s.length),console.log("Signature preview:",s.substring(0,20)+"..."),console.log("Sending to backend...");let c={wallet_address:l,signature:s,message:a};console.log("Request data:",c),console.log("Request JSON:",JSON.stringify(c));let d=await fetch(`${(0,r.k)()}/auth/wallet-connect`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});if(!d.ok){console.log("Wallet connect failed:",d.status);let e=await d.json();throw console.log("Connect error response:",e),Error(e.message||`Wallet connect failed with status ${d.status}`)}let g=await d.json();console.log("Wallet connect successful:",g);let u=g.token||g.access_token||g.auth_token;if(!u){console.log("No token in connect response, trying to register user...");let e=await fetch(`${(0,r.k)()}/auth/register`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({wallet_address:l})});if(e.ok){let t=await e.json();console.log("User registration successful:",t),u=t.token||t.access_token||t.auth_token}else if(409===e.status){console.log("User already exists, getting user info...");let e=await fetch(`${(0,r.k)()}/auth/me`,{method:"GET",headers:{"Content-Type":"application/json"}});if(e.ok){let t=await e.json();console.log("User info retrieved:",t),u=t.token||t.access_token||t.auth_token}}else{console.log("User registration failed:",e.status);let t=await e.json();throw console.log("Register error response:",t),Error(t.message||`User registration failed with status ${e.status}`)}}if(!u)throw Error("No token found after authentication");console.log("Authentication successful"),console.log("Token received:",u),console.log("Token length:",u.length),console.log("Token type:",typeof u),localStorage.setItem("auth_token",u),localStorage.setItem("wallet_address",l),p({walletAddress:l,token:u})}catch(e){console.error("Authentication error:",e),e instanceof TypeError&&e.message.includes("Failed to fetch")?w("Backend server not running. Please start your backend on port 3001."):w(e instanceof Error?e.message:"Authentication failed")}finally{m(!1)}},disconnect=async()=>{if(y){console.log("Already disconnecting, ignoring disconnect request");return}console.log("Disconnecting user..."),console.log("Current wallet state:",{connected:c,wallet:t?.adapter?.name}),v(!0),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address"),p(null),w(null),m(!1);try{t?.adapter?.connected||c?(console.log("Wallet is connected, disconnecting..."),await d(),console.log("Wallet disconnect completed")):console.log("Wallet was not connected")}catch(e){console.log("Error during wallet disconnect:",e)}setTimeout(()=>{v(!1),console.log("User disconnected successfully")},500)};return n.jsx(s.Provider,{value:{user:u,isLoading:h,error:f,connectWallet,disconnect,signMessage,validateToken,wallet:t,connected:c,publicKey:o,setIsLoading:m},children:e})}function useAuth(){let e=(0,l.useContext)(s);if(void 0===e)throw Error("useAuth must be used within an AuthProvider");return e}},2636:(e,t,o)=>{"use strict";o.r(t),o.d(t,{WalletContextProvider:()=>WalletContextProvider});var n=o(784),l=o(9885),a=o(7976),r=o(570),s=o(9223),c=o(1397),i=o(7069),d=o(5854),g=o(5449);o(6457);let WalletContextProvider=({children:e})=>{let t=process.env.NEXT_PUBLIC_SOLANA_NETWORK||s.Q.Mainnet,o=(0,l.useMemo)(()=>process.env.NEXT_PUBLIC_SOLANA_RPC_URL||(0,g.Wf)(t),[t]),u=(0,l.useMemo)(()=>{let e=[];return e.push(new c.O),e.push(new i.e),e},[]);return n.jsx(a.U,{endpoint:o,children:n.jsx(r.n,{wallets:u,autoConnect:!1,onError:e=>{console.error("Wallet error:",e)},children:n.jsx(d.s,{children:e})})})}},8699:(e,t,o)=>{"use strict";o.d(t,{cn:()=>cn,k:()=>getApiUrl});var n=o(566),l=o(8126);function cn(...e){return(0,l.m6)((0,n.W)(e))}function getApiUrl(){return process.env.NEXT_PUBLIC_API_URL||"http://localhost:3001"}},8860:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>RootLayout,metadata:()=>m});var n=o(4656),l=o(2999),a=o.n(l);o(7272);var r=o(5153);let s=(0,r.createProxy)(String.raw`C:\Users\aceda\powerball\front end\app\contexts\WalletProvider.tsx`),{__esModule:c,$$typeof:i}=s;s.default;let d=(0,r.createProxy)(String.raw`C:\Users\aceda\powerball\front end\app\contexts\WalletProvider.tsx#WalletContextProvider`),g=(0,r.createProxy)(String.raw`C:\Users\aceda\powerball\front end\app\contexts\AuthContext.tsx`),{__esModule:u,$$typeof:p}=g;g.default;let h=(0,r.createProxy)(String.raw`C:\Users\aceda\powerball\front end\app\contexts\AuthContext.tsx#AuthProvider`);(0,r.createProxy)(String.raw`C:\Users\aceda\powerball\front end\app\contexts\AuthContext.tsx#useAuth`);let m={title:"Crypto EuroMillions",description:"Mobile-first crypto lottery app",manifest:"/manifest.json",themeColor:"#8B5CF6",viewport:"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no",appleWebApp:{capable:!0,statusBarStyle:"black-translucent",title:"Crypto EuroMillions"},icons:{icon:"/icon-192x192.png",apple:"/icon-192x192.png"}};function RootLayout({children:e}){return n.jsx("html",{lang:"en",className:"dark",children:n.jsx("body",{className:`${a().className} bg-black text-white`,children:n.jsx(d,{children:n.jsx(h,{children:e})})})})}},7272:()=>{}};