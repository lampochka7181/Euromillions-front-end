(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[185],{6601:function(){},4279:function(e,t,o){Promise.resolve().then(o.bind(o,9560)),Promise.resolve().then(o.bind(o,6851)),Promise.resolve().then(o.t.bind(o,1371,23)),Promise.resolve().then(o.t.bind(o,2853,23))},9560:function(e,t,o){"use strict";o.r(t),o.d(t,{AuthProvider:function(){return AuthProvider},useAuth:function(){return useAuth}});var n=o(7437),l=o(2265),a=o(3446),r=o(1628),s=o(7133).Buffer;let c=(0,l.createContext)(void 0);function AuthProvider(e){let{children:t}=e,{wallet:o,publicKey:i,connected:u,connect:d,disconnect:g,wallets:h}=(0,a.O)(),[f,p]=(0,l.useState)(null),[m,w]=(0,l.useState)(!1),[y,v]=(0,l.useState)(null),[k,b]=(0,l.useState)(!1);(0,l.useEffect)(()=>{var e,t;console.log("AuthContext wallet state changed:",{wallet:null==o?void 0:null===(e=o.adapter)||void 0===e?void 0:e.name,connected:u,publicKey:null==i?void 0:i.toString(),walletReady:null==o?void 0:null===(t=o.adapter)||void 0===t?void 0:t.readyState}),(null==o?void 0:o.adapter)&&!u&&console.log("Wallet adapter available:",{name:o.adapter.name,readyState:o.adapter.readyState,connected:o.adapter.connected})},[o,u,i]),(0,l.useEffect)(()=>{let e=localStorage.getItem("auth_token"),t=localStorage.getItem("wallet_address");e&&t&&(console.log("Found existing token:",e),console.log("Token length:",e.length),console.log("Stored wallet address:",t),validateToken(e).then(o=>{if(o){console.log("Token is valid, setting user"),p({walletAddress:t,token:e}),console.log("Attempting to restore wallet connection...");let o=h.find(e=>"Phantom"===e.adapter.name);o&&"Installed"===o.adapter.readyState&&console.log("Phantom wallet is available, checking if we can restore connection")}else console.log("Token is invalid, clearing storage"),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address")}))},[h]),(0,l.useEffect)(()=>{if(!(null==o?void 0:o.adapter))return;let handleAccountChange=()=>{if(k){console.log("Already disconnecting, ignoring account change event");return}console.log("Account changed, disconnecting user"),b(!0),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address"),p(null),v(null),setTimeout(()=>{b(!1)},1e3)};return o.adapter.on("disconnect",handleAccountChange),f&&f.walletAddress&&!u&&"Installed"===o.adapter.readyState&&(console.log("Attempting to restore wallet connection for existing user..."),setTimeout(async()=>{try{await o.adapter.connect(),console.log("Wallet connection restored successfully")}catch(e){console.log("Could not restore wallet connection automatically:",e)}},1e3)),()=>{o.adapter.off("disconnect",handleAccountChange)}},[o,g,f,u]);let signMessage=async e=>{let t=o;if(!t||!t.adapter.publicKey){let e=h.find(e=>"Phantom"===e.adapter.name&&e.adapter.publicKey);e&&(t=e,console.log("Using Phantom wallet from available wallets for signing"))}if(!t||!t.adapter.publicKey)throw Error("Wallet not connected");try{let o=new TextEncoder().encode(e);if(!("signMessage"in t.adapter)||"function"!=typeof t.adapter.signMessage)throw Error("Wallet does not support message signing");let n=await t.adapter.signMessage(o);return s.from(n).toString("base64")}catch(e){throw console.error("Sign message error:",e),Error("Failed to sign message")}},validateToken=async e=>{try{console.log("Validating token..."),console.log("Token being validated:",e),console.log("Authorization header:","Bearer ".concat(e));let t=await fetch("".concat((0,r.k)(),"/auth/me"),{method:"GET",headers:{Authorization:"Bearer ".concat(e),"Content-Type":"application/json"}});if(console.log("Token validation response:",t.status),!t.ok){let e=await t.json().catch(()=>({}));console.log("Token validation error:",e)}return t.ok}catch(e){return console.error("Token validation failed:",e),!1}},connectWallet=async()=>{console.log("Attempting to connect wallet..."),console.log("Available wallet:",o),console.log("Connected:",u),console.log("Public key:",i),console.log("Available wallets in AuthContext:",h.map(e=>e.adapter.name));let e=h.find(e=>"Phantom"===e.adapter.name);if(!e){v("No Phantom wallet found. Please install Phantom wallet and refresh the page."),w(!1);return}console.log("Using Phantom wallet directly for connection"),v(null),w(!0);try{console.log("Connecting with Phantom wallet directly...");try{let t=await e.adapter.connect();console.log("Phantom wallet connect result:",t)}catch(e){console.log("Direct Phantom connect failed:",e),console.log("Trying useWallet connect() as fallback...");try{await d(),console.log("useWallet connect() successful")}catch(e){throw console.log("useWallet connect() also failed:",e),Error("Failed to connect to Phantom wallet")}}await new Promise(e=>setTimeout(e,1e3));let t=null;if(e&&e.adapter.publicKey?(t=e.adapter.publicKey,console.log("Got public key from direct Phantom wallet")):o&&o.adapter&&o.adapter.publicKey?(t=o.adapter.publicKey,console.log("Got public key from selected wallet")):i&&(t=i,console.log("Got public key from useWallet hook")),console.log("Wallet public key (first attempt):",t),!t){console.log("Public key not available, retrying...");for(let n=0;n<10&&(await new Promise(e=>setTimeout(e,300)),e&&e.adapter.publicKey?t=e.adapter.publicKey:o&&o.adapter&&o.adapter.publicKey?t=o.adapter.publicKey:i&&(t=i),console.log("Retry ".concat(n+1,":"),t),!t);n++);}if(!t)throw Error("Failed to get public key from wallet adapter after retries. Please try connecting again.");let n=t.toString(),l="Sign this message to authenticate with Crypto EuroMillions.\nWallet: ".concat(n,"\nTimestamp: ").concat(Date.now());console.log("Signing message...");let a=await signMessage(l);console.log("Message signed successfully"),console.log("Signature length:",a.length),console.log("Signature preview:",a.substring(0,20)+"..."),console.log("Sending to backend...");let s={wallet_address:n,signature:a,message:l};console.log("Request data:",s),console.log("Request JSON:",JSON.stringify(s));let c=await fetch("".concat((0,r.k)(),"/auth/wallet-connect"),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});if(!c.ok){console.log("Wallet connect failed:",c.status);let e=await c.json();throw console.log("Connect error response:",e),Error(e.message||"Wallet connect failed with status ".concat(c.status))}let u=await c.json();console.log("Wallet connect successful:",u);let g=u.token||u.access_token||u.auth_token;if(!g){console.log("No token in connect response, trying to register user...");let e=await fetch("".concat((0,r.k)(),"/auth/register"),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({wallet_address:n})});if(e.ok){let t=await e.json();console.log("User registration successful:",t),g=t.token||t.access_token||t.auth_token}else if(409===e.status){console.log("User already exists, getting user info...");let e=await fetch("".concat((0,r.k)(),"/auth/me"),{method:"GET",headers:{"Content-Type":"application/json"}});if(e.ok){let t=await e.json();console.log("User info retrieved:",t),g=t.token||t.access_token||t.auth_token}}else{console.log("User registration failed:",e.status);let t=await e.json();throw console.log("Register error response:",t),Error(t.message||"User registration failed with status ".concat(e.status))}}if(!g)throw Error("No token found after authentication");console.log("Authentication successful"),console.log("Token received:",g),console.log("Token length:",g.length),console.log("Token type:",typeof g),localStorage.setItem("auth_token",g),localStorage.setItem("wallet_address",n),p({walletAddress:n,token:g})}catch(e){console.error("Authentication error:",e),e instanceof TypeError&&e.message.includes("Failed to fetch")?v("Backend server not running. Please start your backend on port 3001."):v(e instanceof Error?e.message:"Authentication failed")}finally{w(!1)}},disconnect=async()=>{var e,t;if(k){console.log("Already disconnecting, ignoring disconnect request");return}console.log("Disconnecting user..."),console.log("Current wallet state:",{connected:u,wallet:null==o?void 0:null===(e=o.adapter)||void 0===e?void 0:e.name}),b(!0),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address"),p(null),v(null),w(!1);try{(null==o?void 0:null===(t=o.adapter)||void 0===t?void 0:t.connected)||u?(console.log("Wallet is connected, disconnecting..."),await g(),console.log("Wallet disconnect completed")):console.log("Wallet was not connected")}catch(e){console.log("Error during wallet disconnect:",e)}setTimeout(()=>{b(!1),console.log("User disconnected successfully")},500)};return(0,n.jsx)(c.Provider,{value:{user:f,isLoading:m,error:y,connectWallet,disconnect,signMessage,validateToken,wallet:o,connected:u,publicKey:i,setIsLoading:w},children:t})}function useAuth(){let e=(0,l.useContext)(c);if(void 0===e)throw Error("useAuth must be used within an AuthProvider");return e}},6851:function(e,t,o){"use strict";o.r(t),o.d(t,{WalletContextProvider:function(){return WalletContextProvider}});var n=o(7437),l=o(2265),a=o(9399),r=o(666),s=o(6825),c=o(1324),i=o(2668),u=o(3671),d=o(3438),g=o(5566);o(438);let WalletContextProvider=e=>{let{children:t}=e,o=g.env.NEXT_PUBLIC_SOLANA_NETWORK||s.Q.Mainnet,h=(0,l.useMemo)(()=>g.env.NEXT_PUBLIC_SOLANA_RPC_URL||(0,d.clusterApiUrl)(o),[o]),f=(0,l.useMemo)(()=>{let e=[];return e.push(new c.O),e.push(new i.e),e},[]);return(0,n.jsx)(a.U,{endpoint:h,children:(0,n.jsx)(r.n,{wallets:f,autoConnect:!1,onError:e=>{console.error("Wallet error:",e)},children:(0,n.jsx)(u.s,{children:t})})})}},1628:function(e,t,o){"use strict";o.d(t,{cn:function(){return cn},k:function(){return getApiUrl}});var n=o(7042),l=o(4769),a=o(5566);function cn(){for(var e=arguments.length,t=Array(e),o=0;o<e;o++)t[o]=arguments[o];return(0,l.m6)((0,n.W)(t))}function getApiUrl(){return a.env.NEXT_PUBLIC_API_URL||"http://localhost:3001"}},2853:function(){}},function(e){e.O(0,[814,107,264,971,472,744],function(){return e(e.s=4279)}),_N_E=e.O()}]);