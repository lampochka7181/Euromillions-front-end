(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[185],{6601:function(){},4279:function(e,t,o){Promise.resolve().then(o.bind(o,9560)),Promise.resolve().then(o.bind(o,6851)),Promise.resolve().then(o.t.bind(o,1371,23)),Promise.resolve().then(o.t.bind(o,2853,23))},9560:function(e,t,o){"use strict";o.r(t),o.d(t,{AuthProvider:function(){return AuthProvider},useAuth:function(){return useAuth}});var n=o(7437),l=o(2265),a=o(3446),s=o(7133).Buffer;let r=(0,l.createContext)(void 0);function AuthProvider(e){let{children:t}=e,{wallet:o,publicKey:c,connected:i,connect:d,disconnect:u,wallets:g}=(0,a.O)(),[h,p]=(0,l.useState)(null),[f,m]=(0,l.useState)(!1),[w,y]=(0,l.useState)(null),[v,k]=(0,l.useState)(!1);(0,l.useEffect)(()=>{var e,t;console.log("AuthContext wallet state changed:",{wallet:null==o?void 0:null===(e=o.adapter)||void 0===e?void 0:e.name,connected:i,publicKey:null==c?void 0:c.toString(),walletReady:null==o?void 0:null===(t=o.adapter)||void 0===t?void 0:t.readyState}),(null==o?void 0:o.adapter)&&!i&&console.log("Wallet adapter available:",{name:o.adapter.name,readyState:o.adapter.readyState,connected:o.adapter.connected})},[o,i,c]),(0,l.useEffect)(()=>{let e=localStorage.getItem("auth_token"),t=localStorage.getItem("wallet_address");e&&t&&(console.log("Found existing token:",e),console.log("Token length:",e.length),console.log("Stored wallet address:",t),validateToken(e).then(o=>{if(o){console.log("Token is valid, setting user"),p({walletAddress:t,token:e}),console.log("Attempting to restore wallet connection...");let o=g.find(e=>"Phantom"===e.adapter.name);o&&"Installed"===o.adapter.readyState&&console.log("Phantom wallet is available, checking if we can restore connection")}else console.log("Token is invalid, clearing storage"),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address")}))},[g]),(0,l.useEffect)(()=>{if(!(null==o?void 0:o.adapter))return;let handleAccountChange=()=>{if(v){console.log("Already disconnecting, ignoring account change event");return}console.log("Account changed, disconnecting user"),k(!0),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address"),p(null),y(null),setTimeout(()=>{k(!1)},1e3)};return o.adapter.on("disconnect",handleAccountChange),h&&h.walletAddress&&!i&&"Installed"===o.adapter.readyState&&(console.log("Attempting to restore wallet connection for existing user..."),setTimeout(async()=>{try{await o.adapter.connect(),console.log("Wallet connection restored successfully")}catch(e){console.log("Could not restore wallet connection automatically:",e)}},1e3)),()=>{o.adapter.off("disconnect",handleAccountChange)}},[o,u,h,i]);let signMessage=async e=>{let t=o;if(!t||!t.adapter.publicKey){let e=g.find(e=>"Phantom"===e.adapter.name&&e.adapter.publicKey);e&&(t=e,console.log("Using Phantom wallet from available wallets for signing"))}if(!t||!t.adapter.publicKey)throw Error("Wallet not connected");try{let o=new TextEncoder().encode(e);if(!("signMessage"in t.adapter)||"function"!=typeof t.adapter.signMessage)throw Error("Wallet does not support message signing");let n=await t.adapter.signMessage(o);return s.from(n).toString("base64")}catch(e){throw console.error("Sign message error:",e),Error("Failed to sign message")}},validateToken=async e=>{try{console.log("Validating token..."),console.log("Token being validated:",e),console.log("Authorization header:","Bearer ".concat(e));let t=await fetch("http://localhost:3001/auth/me",{method:"GET",headers:{Authorization:"Bearer ".concat(e),"Content-Type":"application/json"}});if(console.log("Token validation response:",t.status),!t.ok){let e=await t.json().catch(()=>({}));console.log("Token validation error:",e)}return t.ok}catch(e){return console.error("Token validation failed:",e),!1}},connectWallet=async()=>{console.log("Attempting to connect wallet..."),console.log("Available wallet:",o),console.log("Connected:",i),console.log("Public key:",c),console.log("Available wallets in AuthContext:",g.map(e=>e.adapter.name));let e=g.find(e=>"Phantom"===e.adapter.name);if(!e){y("No Phantom wallet found. Please install Phantom wallet and refresh the page."),m(!1);return}console.log("Using Phantom wallet directly for connection"),y(null),m(!0);try{console.log("Connecting with Phantom wallet directly...");try{let t=await e.adapter.connect();console.log("Phantom wallet connect result:",t)}catch(e){console.log("Direct Phantom connect failed:",e),console.log("Trying useWallet connect() as fallback...");try{await d(),console.log("useWallet connect() successful")}catch(e){throw console.log("useWallet connect() also failed:",e),Error("Failed to connect to Phantom wallet")}}await new Promise(e=>setTimeout(e,1e3));let t=null;if(e&&e.adapter.publicKey?(t=e.adapter.publicKey,console.log("Got public key from direct Phantom wallet")):o&&o.adapter&&o.adapter.publicKey?(t=o.adapter.publicKey,console.log("Got public key from selected wallet")):c&&(t=c,console.log("Got public key from useWallet hook")),console.log("Wallet public key (first attempt):",t),!t){console.log("Public key not available, retrying...");for(let n=0;n<10&&(await new Promise(e=>setTimeout(e,300)),e&&e.adapter.publicKey?t=e.adapter.publicKey:o&&o.adapter&&o.adapter.publicKey?t=o.adapter.publicKey:c&&(t=c),console.log("Retry ".concat(n+1,":"),t),!t);n++);}if(!t)throw Error("Failed to get public key from wallet adapter after retries. Please try connecting again.");let n=t.toString(),l="Sign this message to authenticate with Crypto EuroMillions.\nWallet: ".concat(n,"\nTimestamp: ").concat(Date.now());console.log("Signing message...");let a=await signMessage(l);console.log("Message signed successfully"),console.log("Signature length:",a.length),console.log("Signature preview:",a.substring(0,20)+"..."),console.log("Sending to backend...");let s={wallet_address:n,signature:a,message:l};console.log("Request data:",s),console.log("Request JSON:",JSON.stringify(s));let r=await fetch("http://localhost:3001/auth/wallet-connect",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(s)});if(!r.ok){console.log("Wallet connect failed:",r.status);let e=await r.json();throw console.log("Connect error response:",e),Error(e.message||"Wallet connect failed with status ".concat(r.status))}let i=await r.json();console.log("Wallet connect successful:",i);let u=i.token||i.access_token||i.auth_token;if(!u){console.log("No token in connect response, trying to register user...");let e=await fetch("http://localhost:3001/auth/register",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({wallet_address:n})});if(e.ok){let t=await e.json();console.log("User registration successful:",t),u=t.token||t.access_token||t.auth_token}else if(409===e.status){console.log("User already exists, getting user info...");let e=await fetch("http://localhost:3001/auth/me",{method:"GET",headers:{"Content-Type":"application/json"}});if(e.ok){let t=await e.json();console.log("User info retrieved:",t),u=t.token||t.access_token||t.auth_token}}else{console.log("User registration failed:",e.status);let t=await e.json();throw console.log("Register error response:",t),Error(t.message||"User registration failed with status ".concat(e.status))}}if(!u)throw Error("No token found after authentication");console.log("Authentication successful"),console.log("Token received:",u),console.log("Token length:",u.length),console.log("Token type:",typeof u),localStorage.setItem("auth_token",u),localStorage.setItem("wallet_address",n),p({walletAddress:n,token:u})}catch(e){console.error("Authentication error:",e),e instanceof TypeError&&e.message.includes("Failed to fetch")?y("Backend server not running. Please start your backend on port 3001."):y(e instanceof Error?e.message:"Authentication failed")}finally{m(!1)}},disconnect=async()=>{var e,t;if(v){console.log("Already disconnecting, ignoring disconnect request");return}console.log("Disconnecting user..."),console.log("Current wallet state:",{connected:i,wallet:null==o?void 0:null===(e=o.adapter)||void 0===e?void 0:e.name}),k(!0),localStorage.removeItem("auth_token"),localStorage.removeItem("wallet_address"),p(null),y(null),m(!1);try{(null==o?void 0:null===(t=o.adapter)||void 0===t?void 0:t.connected)||i?(console.log("Wallet is connected, disconnecting..."),await u(),console.log("Wallet disconnect completed")):console.log("Wallet was not connected")}catch(e){console.log("Error during wallet disconnect:",e)}setTimeout(()=>{k(!1),console.log("User disconnected successfully")},500)};return(0,n.jsx)(r.Provider,{value:{user:h,isLoading:f,error:w,connectWallet,disconnect,signMessage,validateToken,wallet:o,connected:i,publicKey:c,setIsLoading:m},children:t})}function useAuth(){let e=(0,l.useContext)(r);if(void 0===e)throw Error("useAuth must be used within an AuthProvider");return e}},6851:function(e,t,o){"use strict";o.r(t),o.d(t,{WalletContextProvider:function(){return WalletContextProvider}});var n=o(7437),l=o(2265),a=o(9399),s=o(666),r=o(6825),c=o(1324),i=o(2668),d=o(3671),u=o(3438);o(438);let WalletContextProvider=e=>{let{children:t}=e,o=r.Q.Devnet,g=(0,l.useMemo)(()=>(0,u.clusterApiUrl)(o),[o]),h=(0,l.useMemo)(()=>{let e=[];return e.push(new c.O),e.push(new i.e),e},[]);return(0,n.jsx)(a.U,{endpoint:g,children:(0,n.jsx)(s.n,{wallets:h,autoConnect:!1,onError:e=>{console.error("Wallet error:",e)},children:(0,n.jsx)(d.s,{children:t})})})}},2853:function(){}},function(e){e.O(0,[814,310,264,971,472,744],function(){return e(e.s=4279)}),_N_E=e.O()}]);